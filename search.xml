<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[commonJs-ESmodule]]></title>
    <url>%2F2019%2F05%2F15%2FcommonJs-ESmodule%2F</url>
    <content type="text"><![CDATA[commonJscommonJs用于服务端 commonJs是整体加载所有模块，然后再在所有模块的基础上取出部分使用 运行时加载模块 12345678// CommonJS模块let &#123; stat, exists, readFile &#125; = require(&apos;fs&apos;);// 等同于let _fs = require(&apos;fs&apos;);let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile; CommonJS 模块输出的是值的缓存，不存在动态更新 动态加载 12const path = &apos;./&apos; + fileName;const myModual = require(path); 每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见 如果想在多个文件分享变量，必须定义为global对象的属性。 CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。所有缓存的模块保存在require.cache之中，如果想删除模块的缓存 1234567// 删除指定模块的缓存delete require.cache[moduleName];// 删除所有模块的缓存Object.keys(require.cache).forEach(function(key) &#123; delete require.cache[key];&#125;) module对象 1234567891011function Module(id, parent) &#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; // ...module.id 模块的识别符，通常是带有绝对路径的模块文件名。module.filename 模块的文件名，带有绝对路径。module.loaded 返回一个布尔值，表示模块是否已经完成加载。module.parent 返回一个对象，表示调用该模块的模块。module.children 返回一个数组，表示该模块要用到的其他模块。module.exports 表示模块对外输出的值。 module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。 为了方便，Node为每个模块提供一个exports变量，指向module.exports。 CommonJS模块的加载机制是，输入的是被输出的值的拷贝,修改输入的模块不会影响源模块 12这等同在每个模块头部，有一行这样的命令。var exports = module.exports; 不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。exports可以理解为module.exports的一个引用 AMD用于客户端ESmodule 编译时加载模块，并且只加载需要的模块，可以做到静态优化 12// ES6模块import &#123; stat, exists, readFile &#125; from &apos;fs&apos;; export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值 export命令可以出现在模块的任何位置，只要处于模块顶层就可以 import命令输入的变量都是只读的，因为它的本质是输入接口 import命令输入的变量是一个对象，可以改变该对象的属性，但是这样其它所有用到这个模块的地方都会访问到这个属性 import因为是在编译时执行 123foo();import &#123; foo &#125; from &apos;my_module&apos;;上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。 import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构 import()函数返回一个 Promise 对象，它运行时执行 12345678const main = document.querySelector(&apos;main&apos;);import(`./section-modules/$&#123;someVariable&#125;.js`) .then(module =&gt; &#123; module.loadPageInto(main); &#125;).catch(err =&gt; &#123; main.textContent = err.message; &#125;); import类似于commonJs的require，但是前者是异步加载，后者是同步加载]]></content>
  </entry>
  <entry>
    <title><![CDATA[new-webPage]]></title>
    <url>%2F2019%2F05%2F14%2Fnew-webPage%2F</url>
    <content type="text"><![CDATA[网页模板分析登录验证模块前端模块第一种通过cookie实现 前端通过表单提交用户名、密码、记住密码 12345678910axios(&#123; url:&apos;/login&apos;, data:&#123; account:&apos;amdmin&apos;, password:&apos;123456&apos;, remember:true &#125;&#125;).then((res)=&gt;&#123; utils.setCookie(&#123;tooken:res.data.tooken&#125;)&#125;) 设置cookie之后所有的请求都会带上cookie，后台对cookie进行验证，如果tooken没有过期则继续请求数据，如果过期返回过期标识 第二种通过给所有的请求头部添加 Authorization后端模块123456789101112131415161718192021var jwt = require(&apos;jwt-simple&apos;);var app = require(&apos;express&apos;)()const cookieParser = require(&apos;cookie-parser&apos;);const cookieSession = require(&apos;cookie-session&apos;);const expires = Data.now() + 60*60*24*7;var secret = &apos;xxx&apos;;app.use(function(req,res,next)&#123; if(!req.cookies.tooken) &#123;res.status(403);return&#125; var decoded = jwt.decode(token, secret); if(Date.now()&lt;=decoded.tooken)&#123; next() &#125;else&#123; res.status(403);return &#125;&#125;)app.use(&apos;/login&apos;,function(req,res)&#123; var payload = &#123; tooken: expires,name:req.params.name &#125;; var token = jwt.encode(payload, secret); res.send(&#123;status:200,data:&#123;tooken:tooken&#125;&#125;) res.cookie(&apos;cookiename&apos;, &apos;liwen&apos;, &#123;maxAge: 3600&#125;); // 可以在服务端写cookie&#125;) 服务端设置cookie浏览器中看不到###]]></content>
  </entry>
  <entry>
    <title><![CDATA[learn-express]]></title>
    <url>%2F2019%2F05%2F13%2Flearn-express%2F</url>
    <content type="text"><![CDATA[learn expressExpress 是一个保持最小规模的灵活的 Node.js Web 应用程序开发框架，为 Web 和移动应用程序提供一组强大的功能。 安装 express1npm install express --save express()12var express = require(&apos;express&apos;);var app = express(); express本身暴露的方法 express.json() 12用post请求想后台传参数时，数据量比较大时有时会报错express.json(&#123;limit:&apos;500k&apos;&#125;) 静态文件夹express.static() 1app.use(&apos;/static&apos;, express.static(__dirname + &apos;/public&apos;)); express.Router() 12strict默认值为false，“/foo” and “/foo/” are treated the same by the router.express.Router(&#123;strict:true&#125;) express.urlencoded() 1app.use(bodyParser.urlencoded(&#123;extended: false&#125;)); Application app.locals express实例的这个对象存储系统变量 1app.locals.title=&apos;list&apos; app.all() 适配所有http请求方式 1app.all(&apos;*&apos;, requireAuthentication, loadUser); app.disable(name) == app.set(name, false) 设置一个boolean变量 app.enable(name) == app.set(name, true) app.disabled(name)/app.enable(name) 判断一个boolean app.engine() 引入模板文件 app.get(‘name’) 获取由app.set()设置的变量 app.get(path, callback [, callback …]) http请求方式 app.listen() 端口监听，如果不设置端口，会自动指定到一个可用的端口 http.createServer(app).listen(80);1234app.listen = function() &#123; var server = http.createServer(this); return server.listen.apply(server, arguments);&#125;; Request req.baseUrl 123456var greet = express.Router();greet.get(&apos;/jp&apos;, function (req, res) &#123; console.log(req.baseUrl); // /greet res.send(&apos;Konichiwa!&apos;);&#125;);app.use(&apos;/greet&apos;, greet); // load the router on &apos;/greet&apos; req.body 1234567891011var bodyParser = require(&apos;body-parser&apos;);var multer = require(&apos;multer&apos;); // v1.0.5var upload = multer(); // for parsing multipart/form-dataapp.use(bodyParser.json()); // for parsing application/jsonapp.use(bodyParser.urlencoded(&#123; extended: true &#125;)); // for parsing application/x-www-form-urlencodedapp.post(&apos;/profile&apos;, upload.array(), function (req, res, next) &#123; console.log(req.body); res.json(req.body);&#125;); req.cookies 需要用到cookie-parser. 12var cookieParser = require(&apos;cookie-parser&apos;)app.use(cookieParser()) req.fresh req.hostname req.ip req.method 请求方式（get/post） req.baseUrl 1234567这些属性不是express原生的，是继承至httpapp.use(&apos;/admin&apos;, function(req, res, next) &#123; // GET &apos;http://www.example.com/admin/new&apos; console.log(req.originalUrl); // &apos;/admin/new&apos; console.log(req.baseUrl); // &apos;/admin&apos; console.log(req.path); // &apos;/new&apos; next();&#125;); req.params req.protocol req.query 获取问号后面的参数123// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=conversereq.query.order// =&gt; &quot;desc&quot; Response res.cookie(name, value [, options]) 1res.cookie(&apos;rememberme&apos;, &apos;1&apos;, &#123; expires: new Date(Date.now() + 900000), httpOnly: true &#125;); res.clearCookie() 1res.clearCookie(&apos;name&apos;, &#123; path: &apos;/admin&apos; &#125;); res.download(path [, filename] [, options] [, fn]) 客户端提示用户下载 res.end() 可以返回任何数据结束请求 1res.status(404).end(); res.json() 1res.status(500).json(&#123; error: &apos;message&apos; &#125;); res.redirect([status,] path) 12status 默认值为302res.redirect(301, &apos;http://example.com&apos;); res.send([body]) 12参数可以为object/string/arrayres.status(500).send(&#123; error: &apos;something blew up&apos; &#125;); res.render() 一般只有在有模板引擎的时候使用 res.sendFile(path [, options] [, fn]) 返回文件就可以使用 res.sendStatus(statusCode)1234res.sendStatus(200); // equivalent to res.status(200).send(&apos;OK&apos;)res.sendStatus(403); // equivalent to res.status(403).send(&apos;Forbidden&apos;)res.sendStatus(404); // equivalent to res.status(404).send(&apos;Not Found&apos;)res.sendStatus(500); // equivalent to res.status(500).send(&apos;Internal Server Error&apos;) Router router.all() 1router.all(&apos;/api/*&apos;, requireAuthentication); router.method() 12345router.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function(req, res)&#123; var from = req.params[0]; var to = req.params[1] || &apos;HEAD&apos;; res.send(&apos;commit range &apos; + from + &apos;..&apos; + to);&#125;); router.use()]]></content>
  </entry>
  <entry>
    <title><![CDATA[经典语录]]></title>
    <url>%2F2019%2F05%2F05%2Ffirst%2F</url>
    <content type="text"><![CDATA[2019-05-05 水至清则无鱼，人至察则无徒。 大部分时候，人的选择都有一个时间窗口，也就是我们俗话说的，过了这个村，就没这个店了。 太精明的人不明白，这个世界上没有绝对的完美。完美也不是算计出来的，是用心经营出来的。 逢人只说三分话，莫可全交一片心。 一碗米不够，二碗米不够，三碗四碗还是觉得你只给了沧海一粟。 人的善良一定要有度！当一个人不思进取，一味索取帮助时，请及时收起你的善良。 饭局千古事，得失寸唇知。2019-05-08 有时候我们总是肆无忌惮的伤害我们身边的人，因为我们知道，我们根本无法伤害到那些不爱我们的人 太过轻易得到的东西，刚开始会让人觉得欣喜，但长时间下来，会让别人觉得理所当然。人类的劣根性，总是习惯于攀附强者而欺凌弱者 学会拒绝别人，既是对自己的负责，也是对他人的尊重。 所有的烦恼都来源于看不清自己，你那么顾及他人，谁来顾及你？生活是现实的，不会因为你的委曲求全而变得更加美好，是你的心软教会了别人得寸进尺。 与其照顾别人，伤痕累累，不如坚持自己，活得洒脱。 绝大多数的人是因为看见而相信，只有少数的人是因为相信而看见 “我们没有办法跟别人拼昨天，我们也许也没有办法跟别人拼今天，但我们必须跟别人拼未来”。 人生没有彩排，每一天都是现场直播 如果你简单，这个世界就对你简单 怀才就像怀孕，时间久了会让人看出来 人生如果错了方向，停止就是进步 要成功，需要朋友，要取得巨大的成功，需要敌人；天下没有永远的敌人，但是有永远的朋友，有时候敌人也可以成为朋友2019-05-09 抱有被动思维的人，总是习惯承受：世界给我什么，我就接受什么。 习惯受害者思维的人，或许可以获得他人一时的同情与抚慰，但不可能长久。 有字书中聊新知，无字书里品人生。]]></content>
      <tags>
        <tag>经典语录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment ###]]></content>
  </entry>
</search>
