{"meta":{"title":"forever-chen","subtitle":null,"description":null,"author":"forever-chen","url":"forever-chen.github.io","root":"/"},"pages":[],"posts":[{"title":"why-use-node","slug":"why-use-node","date":"2019-06-24T03:37:07.000Z","updated":"2019-06-26T03:26:09.183Z","comments":true,"path":"2019/06/24/why-use-node/","link":"","permalink":"forever-chen.github.io/2019/06/24/why-use-node/","excerpt":"","text":"什么是node Node.js® 是一个基于 Chrome V8 引擎 的 JavaScript 运行环境。 在node中，也是V8引擎负责解释javascriptnode.js特点单线程 在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约2MB内存。 Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。 Node 中最核心的是 v8 引擎，在 Node 启动后，会创建 v8 的实例，这个实例是多线程的 大家常说的 Node 是单线程的指的是 JavaScript 的执行是单线程的，但 Javascript 的宿主环境，无论是 Node 还是浏览器都是多线程的。 Node 中有一些 IO 操作（DNS，FS）和一些 CPU 密集计算（Zlib，Crypto）会启用 Node 的线程池，而线程池默认大小为 4 因为 Node 中提供了 cluster 模块，cluster 实现了对 child_process 的封装，通过 fork 方法创建子进程的方式实现了多进程模型。 Node并非真正的单线程架构，Node自身还有一定的I/O线程存在，这些I/O线程由底层libuv处理，这就意味着Node在访问系统I/O时还是多线程的，对于文件读取、SQL查询、网路请求这些具体操作，Node还是使用多线程来进行处理从而保证Node的处理效率。 1234567891011主线程：编译、执行代码。编译/优化线程：在主线程执行的时候，可以优化代码。分析器线程：记录分析代码运行时间，为 Crankshaft 优化代码执行提供依据。垃圾回收的几个线程。优点：1.操作系统完全不再有线程创建，销毁的时间开销2.不用像多线程编程一样处处在意状态的同步问题缺点：1.无法利用多核CPU2.一个用户造成线程奔溃，整个服务都奔溃，应用健壮性需要考虑3.大量计算占用CPU导致无法继续调用异步I/O 延伸阅读Node 10.5.0 的发布worker_thread 模块 非阻塞I/O 阻塞 是指在 Node.js 程序中，其它 JavaScript 语句的执行，必须等待一个非 JavaScript 操作完成。 在 Node.js 标准库中的所有 I/O 方法都提供异步版本，非阻塞，并且接受回调函数。 阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。 概念：阻塞、非阻塞、同步、异步事件驱动 event-driven 在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。node适合在哪里用善于I/O，不善于计算 善于i/o是因为它最擅长的就是人物调度 当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。 1234用户表单收集考试系统聊天室图文直播 Node.js没有web容器,不像其它的jsp、php等一样，直接通过静态路径就可以访问文件 了解概念高并发 高并发：是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。 高并发的指标：响应时间（Response Time），吞吐量（Throughput），每秒查询率QPS（Query Per Second），并发用户数nodejs流行框架","categories":[],"tags":[]},{"title":"read-note","slug":"read-note","date":"2019-06-19T01:28:28.000Z","updated":"2019-06-19T01:57:05.808Z","comments":true,"path":"2019/06/19/read-note/","link":"","permalink":"forever-chen.github.io/2019/06/19/read-note/","excerpt":"","text":"变革中国毛泽东去世 1976-9-9毛泽东去世，69年毛泽东力排众议把林彪委任接班人，并在9次全国人大代表大会写入党章 林彪是在文化大革命期间在大会上公然反对彭德怀而被重用，彭德怀参加过抗美援朝之后任职国防部长，但是之后被林彪取代，林彪把毛主席语录当成从不离手的“道具” 林彪野心太大，文化大革命期间想造反，之后被发现坐飞机逃跑坠落 林彪死了之后，华国锋成为了接班人，毛去世之后提出了两个凡是 四人帮也是在文化大革命期间发展起来的（毛泽东的遗孀江青、王洪文、张春桥、姚文元） 76年秘密处决了四人帮，计划周密 反对毛泽东的以阶级斗争为主的发展路线，提出以经济建设为中，并重新启动了周恩来的四个现代化（在文化大革命期间提出但是没有被慎重考虑） 此时邓小平由于反对毛泽东的大跃进和文化大革命被流放到工厂做工人，直到此时被重用，委任国务院副总理 在这期间把文化大革命发展起来的一些地方以及省级官员全部换血（重视人才和教育） 华国锋是政治新手，政治资源比较少，邓小平、陈云等人一直都是思想一致的领导人 邓小平和华国锋都是主要发展经济所以当时的经济发展相当迅速（引入国外的先进技术发展、甚至走国际贷款） 毛泽东的反对中央集权在华国锋和邓小平这里得到支持，但是华国锋还是发展了个人中心主义（类似于毛泽东）为了巩固自己的权利 这一点收到许多人的反对，由于自己又没有政治资源，所以慢慢被排挤，先后丢了军委主席和国务院总理的位置 虽然他的有些思想还是不够正面，但是发展经济使得中国走上一条正常的发展道路 从80年代后期慢慢中国慢慢走向了市场经济 虽然这期间有许多的观点反对毛泽东的思想，但是毛泽东提出的论十大关系和实事求是的思想方针还是被强烈支持的","categories":[],"tags":[]},{"title":"singile-spa","slug":"singile-spa","date":"2019-06-18T07:31:26.000Z","updated":"2019-06-18T11:52:02.674Z","comments":true,"path":"2019/06/18/singile-spa/","link":"","permalink":"forever-chen.github.io/2019/06/18/singile-spa/","excerpt":"","text":"single-spa学习笔记 官方例子 官方文档文档学习解决问题以及优点 在同一项目中使用多套框架 多套系统之间独立部署 重构代码，可以对功能进行拆分重构 懒加载实现对应用的按需加载(单页面应用也可以实现)浏览器兼容性（Chrome, Firefox, Safari, IE11, and Edge)####","categories":[],"tags":[]},{"title":"react再学习","slug":"react再学习","date":"2019-05-29T09:27:49.000Z","updated":"2019-05-30T03:29:11.931Z","comments":true,"path":"2019/05/29/react再学习/","link":"","permalink":"forever-chen.github.io/2019/05/29/react再学习/","excerpt":"","text":"context Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法(利用这个功能设置切换主题，改变根元素的类名)。1234567891011121314151617181920212223242526272829303132333435// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。// 为当前的 theme 创建一个 context（“light”为默认值）。const ThemeContext = React.createContext(&apos;light&apos;);class App extends React.Component &#123;render() &#123; // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。 // 无论多深，任何组件都能读取这个值。 // 在这个例子中，我们将 “dark” 作为当前的值传递下去。 return ( &lt;ThemeContext.Provider value=&quot;dark&quot;&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; );&#125;&#125;// 中间的组件再也不必指明往下传递 theme 了。function Toolbar(props) &#123;return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt;);&#125;class ThemedButton extends React.Component &#123;// 指定 contextType 读取当前的 theme context。// React 会往上找到最近的 theme Provider，然后使用它的值。// 在这个例子中，当前的 theme 值为 “dark”。static contextType = ThemeContext;render() &#123; return &lt;Button theme=&#123;this.context&#125; /&gt;;&#125;&#125; APIReact.createContext1const MyContext = React.createContext(defaultValue); 创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。 Context.Provider1&lt;MyContext.Provider value=&#123;/* 某个值 */&#125;&gt; 每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。 当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。 Class.contextType12345678910111213141516171819class MyClass extends React.Component &#123;componentDidMount() &#123; let value = this.context; /* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */&#125;componentDidUpdate() &#123; let value = this.context; /* ... */&#125;componentWillUnmount() &#123; let value = this.context; /* ... */&#125;render() &#123; let value = this.context; /* 基于 MyContext 组件的值进行渲染 */&#125;&#125;MyClass.contextType = MyContext; 挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。这能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。 错误边界错误类型 事件处理 异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数） 服务端渲染 它自身抛出来的错误（并非它的子组件） 如果一个 class 组件中定义了 static getDerivedStateFromError() 或 componentDidCatch() 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。当抛出错误后，请使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息。 1234567891011121314151617181920212223242526272829class ErrorBoundary extends React.Component &#123;constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;;&#125;static getDerivedStateFromError(error) &#123; // Update state so the next render will show the fallback UI. return &#123; hasError: true &#125;;&#125;componentDidCatch(error, info) &#123; // You can also log the error to an error reporting service logErrorToMyService(error, info);&#125;render() &#123; if (this.state.hasError) &#123; // You can render any custom fallback UI return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125;// 组件的使用&lt;ErrorBoundary&gt; &lt;MyWidget /&gt;&lt;/ErrorBoundary&gt; 错误边界的工作方式类似于 JavaScript 的 catch {}，不同的地方在于错误边界只针对 React 组件。只有 class 组件才可以成为成错误边界组件。大多数情况下, 你只需要声明一次错误边界组件, 并在整个应用中使用它。 错误边界的粒度由你来决定，可以将其包装在最顶层的路由组件并为用户展示一个 “Something went wrong” 的错误信息，就像服务端框架经常处理崩溃一样。你也可以将单独的部件包装在错误边界以保护应用其他部分不崩溃。 自 React 16 起，任何未被错误边界捕获的错误将会导致整个 React 组件树被卸载。 (React 16 还提供了组件栈追踪，现在你可以准确地查看发生在组件树内的错误信息，但是它仅仅适用于开发环境)[https://www.npmjs.com/package/babel-plugin-transform-react-jsx-source] React.forwardRef123456789const FancyButton = React.forwardRef((props, ref) =&gt; (&lt;button ref=&#123;ref&#125; className=&quot;FancyButton&quot;&gt; &#123;props.children&#125;&lt;/button&gt;));// 你可以直接获取 DOM button 的 ref：const ref = React.createRef();&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt;; 这样，使用 FancyButton 的组件可以获取底层 DOM 节点 button 的 ref ，并在必要时访问，就像其直接使用 DOM button 一样。 Fragments React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。123456789render() &#123; return ( &lt;React.Fragment&gt; //编译之后不会生成dom元素 &lt;ChildA /&gt; &lt;ChildB /&gt; &lt;ChildC /&gt; &lt;/React.Fragment&gt; );&#125; react性能提升Brunch 通过安装 uglify-js-brunch 插件，来获得最高效的 Brunch 生产构建： 1234567# 如果你使用 npmnpm install --save-dev uglify-js-brunch# 如果你使用 Yarnyarn add --dev uglify-js-brunch接着，在 build 命令后添加 -p 参数，以创建生产构建：brunch build -p 请注意，你只需要在生产构建时这么做。你不需要在开发环境中使用 -p 参数或者应用这个插件，因为这会隐藏有用的 React 警告信息并使得构建速度变慢。 你可以继承 React.PureComponent 以代替手写 shouldComponentUpdate()。它用当前与之前 props 和 state 的浅比较覆写了 shouldComponentUpdate() 的实现。 Immutable.js与shouldComponentUpdate结合使用提高性能PortalsPortal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。12ReactDOM.createPortal(child, container)第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 fragment。第二个参数（container）是一个 DOM 元素。","categories":[],"tags":[]},{"title":"react-hooks","slug":"react-hooks","date":"2019-05-29T08:41:28.000Z","updated":"2019-06-03T07:06:25.987Z","comments":true,"path":"2019/05/29/react-hooks/","link":"","permalink":"forever-chen.github.io/2019/05/29/react-hooks/","excerpt":"","text":"react hooks笔记react hook产生背景 class 不能很好的压缩，并且会使热重载出现不稳定 在组件之间复用状态逻辑很难 复杂组件变得难以理解Hook 使用规则 只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。 只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中，我们稍后会学习到。）新的apiState Hook1234567891011121314151617181920import React, &#123; useState &#125; from &apos;react&apos;;function Example() &#123;// 声明一个叫 “count” 的 state 变量。const [count, setCount] = useState(0);// 声明多个 state 变量！const [age, setAge] = useState(42);const [fruit, setFruit] = useState(&apos;banana&apos;);const [todos, setTodos] = useState([&#123; text: &apos;Learn Hooks&apos; &#125;]);return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; // setCount可以接受函数为参数，参数为上一个state &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/button&gt; &lt;/div&gt;);&#125; Effect HookuseEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API。（我们会在使用 Effect Hook 里展示对比 useEffect 和这些方法的例子。）12345678910111213141516171819202122232425262728293031323334353637import React, &#123; useState, useEffect &#125; from &apos;react&apos;;function Example() &#123;const [count, setCount] = useState(0);// 相当于 componentDidMount 和 componentDidUpdate:useEffect(() =&gt; &#123; // 使用浏览器的 API 更新页面标题 document.title = `You clicked $&#123;count&#125; times`;&#125;);// 相当于 componentDidMountuseEffect(() =&gt; &#123; // 使用浏览器的 API 更新页面标题 document.title = `You clicked $&#123;count&#125; times`;&#125;,[]);// 相当于 componentDidMount和count发生变化时触发effect，类似于shouldComponentWillMountuseEffect(() =&gt; &#123; // 使用浏览器的 API 更新页面标题 document.title = `You clicked $&#123;count&#125; times`;&#125;,[count]);return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt;);&#125;// 为防止内存泄漏，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则在执行下一个 effect 之前，上一个 effect 就已被清除。useEffect(() =&gt; &#123;const subscription = props.source.subscribe();return () =&gt; &#123; // 清除订阅 subscription.unsubscribe();&#125;;&#125;); 副作用函数还可以通过返回一个函数来指定如何“清除”副作用 useContext1const value = useContext(MyContext); 接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定。当组件上层最近的 &lt;MyContext.Provider&gt; 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值。","categories":[],"tags":[]},{"title":"WeChartPublicAccount","slug":"WeChartPublicAccount","date":"2019-05-22T06:26:41.000Z","updated":"2019-05-22T06:33:06.911Z","comments":true,"path":"2019/05/22/WeChartPublicAccount/","link":"","permalink":"forever-chen.github.io/2019/05/22/WeChartPublicAccount/","excerpt":"","text":"微信公众号开发准备工作 在github上克隆例子 由于微信公众号测试服务器必须是线上服务器，本地服务器不能，所有下载代理服务器 然后为了方便起见，把代理服务器解压到例子的根目录下，执行命令.\\ngrok.exe http &lt;你的node服务器的端口号&gt;","categories":[],"tags":[]},{"title":"commonJs-ESmodule","slug":"commonJs-ESmodule","date":"2019-05-15T07:40:26.000Z","updated":"2019-05-15T07:40:43.824Z","comments":true,"path":"2019/05/15/commonJs-ESmodule/","link":"","permalink":"forever-chen.github.io/2019/05/15/commonJs-ESmodule/","excerpt":"","text":"commonJscommonJs用于服务端 commonJs是整体加载所有模块，然后再在所有模块的基础上取出部分使用 运行时加载模块 12345678// CommonJS模块let &#123; stat, exists, readFile &#125; = require(&apos;fs&apos;);// 等同于let _fs = require(&apos;fs&apos;);let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile; CommonJS 模块输出的是值的缓存，不存在动态更新 动态加载 12const path = &apos;./&apos; + fileName;const myModual = require(path); 每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见 如果想在多个文件分享变量，必须定义为global对象的属性。 CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。所有缓存的模块保存在require.cache之中，如果想删除模块的缓存 1234567// 删除指定模块的缓存delete require.cache[moduleName];// 删除所有模块的缓存Object.keys(require.cache).forEach(function(key) &#123; delete require.cache[key];&#125;) module对象 1234567891011function Module(id, parent) &#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; // ...module.id 模块的识别符，通常是带有绝对路径的模块文件名。module.filename 模块的文件名，带有绝对路径。module.loaded 返回一个布尔值，表示模块是否已经完成加载。module.parent 返回一个对象，表示调用该模块的模块。module.children 返回一个数组，表示该模块要用到的其他模块。module.exports 表示模块对外输出的值。 module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。 为了方便，Node为每个模块提供一个exports变量，指向module.exports。 CommonJS模块的加载机制是，输入的是被输出的值的拷贝,修改输入的模块不会影响源模块 12这等同在每个模块头部，有一行这样的命令。var exports = module.exports; 不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。exports可以理解为module.exports的一个引用 AMD用于客户端ESmodule 编译时加载模块，并且只加载需要的模块，可以做到静态优化 12// ES6模块import &#123; stat, exists, readFile &#125; from &apos;fs&apos;; export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值 export命令可以出现在模块的任何位置，只要处于模块顶层就可以 import命令输入的变量都是只读的，因为它的本质是输入接口 import命令输入的变量是一个对象，可以改变该对象的属性，但是这样其它所有用到这个模块的地方都会访问到这个属性 import因为是在编译时执行 123foo();import &#123; foo &#125; from &apos;my_module&apos;;上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。 import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构 import()函数返回一个 Promise 对象，它运行时执行 12345678const main = document.querySelector(&apos;main&apos;);import(`./section-modules/$&#123;someVariable&#125;.js`) .then(module =&gt; &#123; module.loadPageInto(main); &#125;).catch(err =&gt; &#123; main.textContent = err.message; &#125;); import类似于commonJs的require，但是前者是异步加载，后者是同步加载","categories":[],"tags":[]},{"title":"new-webPage","slug":"new-webPage","date":"2019-05-14T08:08:49.000Z","updated":"2019-05-14T10:22:11.888Z","comments":true,"path":"2019/05/14/new-webPage/","link":"","permalink":"forever-chen.github.io/2019/05/14/new-webPage/","excerpt":"","text":"网页模板分析登录验证模块前端模块第一种通过cookie实现 前端通过表单提交用户名、密码、记住密码 12345678910axios(&#123; url:&apos;/login&apos;, data:&#123; account:&apos;amdmin&apos;, password:&apos;123456&apos;, remember:true &#125;&#125;).then((res)=&gt;&#123; utils.setCookie(&#123;tooken:res.data.tooken&#125;)&#125;) 设置cookie之后所有的请求都会带上cookie，后台对cookie进行验证，如果tooken没有过期则继续请求数据，如果过期返回过期标识 第二种通过给所有的请求头部添加 Authorization后端模块123456789101112131415161718192021var jwt = require(&apos;jwt-simple&apos;);var app = require(&apos;express&apos;)()const cookieParser = require(&apos;cookie-parser&apos;);const cookieSession = require(&apos;cookie-session&apos;);const expires = Data.now() + 60*60*24*7;var secret = &apos;xxx&apos;;app.use(function(req,res,next)&#123; if(!req.cookies.tooken) &#123;res.status(403);return&#125; var decoded = jwt.decode(token, secret); if(Date.now()&lt;=decoded.tooken)&#123; next() &#125;else&#123; res.status(403);return &#125;&#125;)app.use(&apos;/login&apos;,function(req,res)&#123; var payload = &#123; tooken: expires,name:req.params.name &#125;; var token = jwt.encode(payload, secret); res.send(&#123;status:200,data:&#123;tooken:tooken&#125;&#125;) res.cookie(&apos;cookiename&apos;, &apos;liwen&apos;, &#123;maxAge: 3600&#125;); // 可以在服务端写cookie&#125;) 服务端设置cookie浏览器中看不到###","categories":[],"tags":[]},{"title":"learn-express","slug":"learn-express","date":"2019-05-13T08:25:39.000Z","updated":"2019-05-14T03:14:27.984Z","comments":true,"path":"2019/05/13/learn-express/","link":"","permalink":"forever-chen.github.io/2019/05/13/learn-express/","excerpt":"","text":"learn expressExpress 是一个保持最小规模的灵活的 Node.js Web 应用程序开发框架，为 Web 和移动应用程序提供一组强大的功能。 安装 express1npm install express --save express()12var express = require(&apos;express&apos;);var app = express(); express本身暴露的方法 express.json() 12用post请求想后台传参数时，数据量比较大时有时会报错express.json(&#123;limit:&apos;500k&apos;&#125;) 静态文件夹express.static() 1app.use(&apos;/static&apos;, express.static(__dirname + &apos;/public&apos;)); express.Router() 12strict默认值为false，“/foo” and “/foo/” are treated the same by the router.express.Router(&#123;strict:true&#125;) express.urlencoded() 1app.use(bodyParser.urlencoded(&#123;extended: false&#125;)); Application app.locals express实例的这个对象存储系统变量 1app.locals.title=&apos;list&apos; app.all() 适配所有http请求方式 1app.all(&apos;*&apos;, requireAuthentication, loadUser); app.disable(name) == app.set(name, false) 设置一个boolean变量 app.enable(name) == app.set(name, true) app.disabled(name)/app.enable(name) 判断一个boolean app.engine() 引入模板文件 app.get(‘name’) 获取由app.set()设置的变量 app.get(path, callback [, callback …]) http请求方式 app.listen() 端口监听，如果不设置端口，会自动指定到一个可用的端口 http.createServer(app).listen(80);1234app.listen = function() &#123; var server = http.createServer(this); return server.listen.apply(server, arguments);&#125;; Request req.baseUrl 123456var greet = express.Router();greet.get(&apos;/jp&apos;, function (req, res) &#123; console.log(req.baseUrl); // /greet res.send(&apos;Konichiwa!&apos;);&#125;);app.use(&apos;/greet&apos;, greet); // load the router on &apos;/greet&apos; req.body 1234567891011var bodyParser = require(&apos;body-parser&apos;);var multer = require(&apos;multer&apos;); // v1.0.5var upload = multer(); // for parsing multipart/form-dataapp.use(bodyParser.json()); // for parsing application/jsonapp.use(bodyParser.urlencoded(&#123; extended: true &#125;)); // for parsing application/x-www-form-urlencodedapp.post(&apos;/profile&apos;, upload.array(), function (req, res, next) &#123; console.log(req.body); res.json(req.body);&#125;); req.cookies 需要用到cookie-parser. 12var cookieParser = require(&apos;cookie-parser&apos;)app.use(cookieParser()) req.fresh req.hostname req.ip req.method 请求方式（get/post） req.baseUrl 1234567这些属性不是express原生的，是继承至httpapp.use(&apos;/admin&apos;, function(req, res, next) &#123; // GET &apos;http://www.example.com/admin/new&apos; console.log(req.originalUrl); // &apos;/admin/new&apos; console.log(req.baseUrl); // &apos;/admin&apos; console.log(req.path); // &apos;/new&apos; next();&#125;); req.params req.protocol req.query 获取问号后面的参数123// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=conversereq.query.order// =&gt; &quot;desc&quot; Response res.cookie(name, value [, options]) 1res.cookie(&apos;rememberme&apos;, &apos;1&apos;, &#123; expires: new Date(Date.now() + 900000), httpOnly: true &#125;); res.clearCookie() 1res.clearCookie(&apos;name&apos;, &#123; path: &apos;/admin&apos; &#125;); res.download(path [, filename] [, options] [, fn]) 客户端提示用户下载 res.end() 可以返回任何数据结束请求 1res.status(404).end(); res.json() 1res.status(500).json(&#123; error: &apos;message&apos; &#125;); res.redirect([status,] path) 12status 默认值为302res.redirect(301, &apos;http://example.com&apos;); res.send([body]) 12参数可以为object/string/arrayres.status(500).send(&#123; error: &apos;something blew up&apos; &#125;); res.render() 一般只有在有模板引擎的时候使用 res.sendFile(path [, options] [, fn]) 返回文件就可以使用 res.sendStatus(statusCode)1234res.sendStatus(200); // equivalent to res.status(200).send(&apos;OK&apos;)res.sendStatus(403); // equivalent to res.status(403).send(&apos;Forbidden&apos;)res.sendStatus(404); // equivalent to res.status(404).send(&apos;Not Found&apos;)res.sendStatus(500); // equivalent to res.status(500).send(&apos;Internal Server Error&apos;) Router router.all() 1router.all(&apos;/api/*&apos;, requireAuthentication); router.method() 12345router.get(/^\\/commits\\/(\\w+)(?:\\.\\.(\\w+))?$/, function(req, res)&#123; var from = req.params[0]; var to = req.params[1] || &apos;HEAD&apos;; res.send(&apos;commit range &apos; + from + &apos;..&apos; + to);&#125;); router.use()","categories":[],"tags":[]},{"title":"经典语录","slug":"first","date":"2019-05-05T12:54:17.000Z","updated":"2019-06-11T01:34:59.048Z","comments":true,"path":"2019/05/05/first/","link":"","permalink":"forever-chen.github.io/2019/05/05/first/","excerpt":"","text":"2019-05-05 水至清则无鱼，人至察则无徒。 大部分时候，人的选择都有一个时间窗口，也就是我们俗话说的，过了这个村，就没这个店了。 太精明的人不明白，这个世界上没有绝对的完美。完美也不是算计出来的，是用心经营出来的。 逢人只说三分话，莫可全交一片心。 一碗米不够，二碗米不够，三碗四碗还是觉得你只给了沧海一粟。 人的善良一定要有度！当一个人不思进取，一味索取帮助时，请及时收起你的善良。 饭局千古事，得失寸唇知。2019-05-08 有时候我们总是肆无忌惮的伤害我们身边的人，因为我们知道，我们根本无法伤害到那些不爱我们的人 太过轻易得到的东西，刚开始会让人觉得欣喜，但长时间下来，会让别人觉得理所当然。人类的劣根性，总是习惯于攀附强者而欺凌弱者 学会拒绝别人，既是对自己的负责，也是对他人的尊重。 所有的烦恼都来源于看不清自己，你那么顾及他人，谁来顾及你？生活是现实的，不会因为你的委曲求全而变得更加美好，是你的心软教会了别人得寸进尺。 与其照顾别人，伤痕累累，不如坚持自己，活得洒脱。 绝大多数的人是因为看见而相信，只有少数的人是因为相信而看见 “我们没有办法跟别人拼昨天，我们也许也没有办法跟别人拼今天，但我们必须跟别人拼未来”。 人生没有彩排，每一天都是现场直播 如果你简单，这个世界就对你简单 怀才就像怀孕，时间久了会让人看出来 人生如果错了方向，停止就是进步 要成功，需要朋友，要取得巨大的成功，需要敌人；天下没有永远的敌人，但是有永远的朋友，有时候敌人也可以成为朋友2019-05-09 抱有被动思维的人，总是习惯承受：世界给我什么，我就接受什么。 习惯受害者思维的人，或许可以获得他人一时的同情与抚慰，但不可能长久。 有字书中聊新知，无字书里品人生。2019-06-11 用眼看世界，难免一叶障目；用心观世界，万物尽收眼底；而用一个优等的心去触摸世界，一人一物，一草一木，一山一水，皆明朗历历。 去靠近内心自带光源的人，不仅可以在我们的生活中为自己的人生指路，而且可以为他人照明。 点燃自身的光源，去照亮别人，则是人生远行的终极目标。 比成功 和幸福都重要的是，一个人必须有一个真实的自我，一颗饱满的灵魂，他决定了一个人争取成功和体验幸福的能力。 一个人若是内心自带光源，便不依附，不盲从，终极一生都会独善其身，于人生，于生活，都在学最好的别人，做最好的自己。 人生不如意事十之八九，生活却从不会厚此薄彼。 做一个内心自带光源的人，播种你的善良，让美好天天不期而遇；发出你的光芒，每一天的微笑都是你最美的模样。","categories":[],"tags":[{"name":"经典语录","slug":"经典语录","permalink":"forever-chen.github.io/tags/经典语录/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-05-05T11:55:53.432Z","updated":"2019-05-13T08:38:24.625Z","comments":true,"path":"2019/05/05/hello-world/","link":"","permalink":"forever-chen.github.io/2019/05/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment ###","categories":[],"tags":[]}]}